import wixData from 'wix-data';
import { mediaManager } from 'wix-media-backend';
import pdfParse from 'pdf-parse';
import { OpenAI } from 'openai';
import { getSecret } from 'wix-secrets-backend';
import https from 'https';

// Download PDF as a buffer
async function getFileAsBuffer(url) {
  return new Promise((resolve, reject) => {
    const req = https.get(url, (res) => {
      if (res.statusCode !== 200) {
        reject(new Error(`Failed with status code: ${res.statusCode}`));
        return;
      }
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        const buffer = Buffer.concat(chunks);
        resolve(buffer);
      });
    });
    req.on('error', reject);
  });
}

// Timeout wrapper for OpenAI API calls
const withTimeout = (promise, ms) => {
  const timeout = new Promise((_, reject) => 
    setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)
  );
  return Promise.race([promise, timeout]);
};

// Batch translate English menu item names to Arabic
async function translateToArabic(names, openai) {
  if (!names.length) return [];
  try {
    console.log(`Batch translating ${names.length} items to Arabic:`, names);
    const start = Date.now();
    const response = await withTimeout(
      openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: 'Translate the English menu item names to Arabic. Return a JSON array of translations in the same order.' },
          { role: 'user', content: JSON.stringify(names) }
        ],
        temperature: 0.3
      }),
      10000 // 10-second timeout
    );
    const translations = JSON.parse(response.choices[0].message.content.trim());
    console.log(`Batch translation completed in ${Date.now() - start}ms:`, translations);
    return translations;
  } catch (err) {
    console.error('Batch translation failed:', { message: err.message, stack: err.stack });
    return names; // Fallback to English names
  }
}

// Extract menu items from text
async function extractInventoryFromText(text, fileUrl, ownerId) {
  const start = Date.now();
  console.log(`Starting extractInventoryFromText for ownerId: ${ownerId}, fileUrl: ${fileUrl}`);
  
  const apiKey = await getSecret('OPENAI_API_KEY');
  const openai = new OpenAI({ apiKey });

  const systemPrompt = `
Extract a bilingual JSON array of menu items from a restaurant menu in Arabic and English.
Ignore non-menu content such as introductions, restaurant descriptions, policies, or general information.
Focus only on items listed as food, beverages, or specific dishes with optional quantities, prices, or descriptions.
Each object must contain:
- "itemName_ar" (Arabic name if present, leave empty if not)
- "name" (English name if present)
- "quantity" (numeric, default 1 if missing, extract from text like ': 12' or '12')
- "price" (numeric, extract price in EGP like '12 EGP' or '11 EGP', default 0 if not found)
- "description_ar" and "description" (if available, empty string if not)
Return *only a valid JSON array*. No text or explanations.
  `;

  const userContent = `
Text: ${text.slice(0, 4000)}
Source: ${fileUrl}
  `;

  let raw;
  try {
    const extractStart = Date.now();
    const response = await withTimeout(
      openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userContent }
        ],
        temperature: 0.3,
        max_tokens: 4096
      }),
      15000 // 15-second timeout
    );
    raw = response.choices[0].message.content?.trim();
    console.log(`OpenAI extraction completed in ${Date.now() - extractStart}ms for ownerId: ${ownerId}, Raw:`, raw);
  } catch (err) {
    console.error(`OpenAI extraction failed for ownerId: ${ownerId}:`, { message: err.message, stack: err.stack });
    return [];
  }

  // Strip ```json ... ``` if present
  if (raw.startsWith("```json")) raw = raw.slice(7);
  if (raw.endsWith("```")) raw = raw.slice(0, -3);

  let parsed;
  try {
    parsed = JSON.parse(raw);
  } catch (err) {
    try {
      // Fix common JSON issues: trailing commas, unclosed arrays
      let fixed = raw.trim();
      fixed = fixed.replace(/,\s*$/, ''); // Remove trailing comma
      if (!fixed.endsWith(']')) fixed += ']';
      if (!fixed.startsWith('[')) fixed = '[' + fixed;
      parsed = JSON.parse(fixed);
      console.log(`Fixed malformed JSON for ownerId: ${ownerId}, Fixed:`, fixed);
    } catch (secondErr) {
      console.error(`Invalid JSON from OpenAI for ownerId: ${ownerId}, Raw: ${raw}, Error:`, { message: secondErr.message, stack: secondErr.stack });
      return [];
    }
  }

  if (!Array.isArray(parsed)) {
    console.warn(`Expected JSON array, got: ${typeof parsed} for ownerId: ${ownerId}`);
    return [];
  }

  // Batch translate English names to Arabic
  const names = parsed.map(item => item.name).filter(Boolean);
  const translations = await translateToArabic(names, openai);
  parsed.forEach((item, index) => {
    if (item.name && translations[index]) {
      item.itemName_ar = translations[index];
    }
    item.description_ar = item.description_ar ?? '';
    item.description = item.description ?? '';
  });

  const validItems = parsed.filter(i => (i.name || i.itemName_ar) && (i.name?.trim().length > 0 || i.itemName_ar?.trim().length > 0));
  console.log(`Validated menu items for ownerId: ${ownerId} in ${Date.now() - start}ms:`, validItems);
  return validItems;
}

// Insert or update menu items in MenuItems collection
async function upsertInventory(item, ownerId, fileUrl) {
  const {
    name = '', itemName_ar = '',
    description = '', description_ar = '',
    quantity = 0, price = 0
  } = item;

  if (!name && !itemName_ar) {
    console.warn(`Skipping invalid item (no name) for ownerId: ${ownerId}`, item);
    return;
  }

  const normalizedName = name.toLowerCase().split(' ').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');

  const data = {
    ownerId,
    name: normalizedName || itemName_ar,
    itemName_ar,
    description,
    description_ar,
    quantity,
    price,
    sourcePdfUrl: fileUrl
  };

  const existing = await wixData.query('MenuItems')
    .eq('ownerId', ownerId)
    .eq('name', normalizedName)
    .find();
  if (existing.items.length > 0) {
    await wixData.update('MenuItems', { ...existing.items[0], ...data });
    console.log(`Updated item for ownerId ${ownerId}: ${normalizedName}`);
  } else {
    await wixData.insert('MenuItems', data);
    console.log(`Inserted item for ownerId ${ownerId}: ${normalizedName}`);
  }
}

// Process PDF and extract menu items
export async function uploadAndProcessPDF(fileUrl, ownerId) {
  try {
    console.log('Processing file for ownerId:', ownerId, fileUrl);
    const start = Date.now();

    // Create a new PDF record
    const newPDF = await wixData.insert('PDFs', { fileUrl, ownerId });
    const pdfId = newPDF._id;
    console.log(`Created PDF record in ${Date.now() - start}ms, pdfId: ${pdfId}`);

    // Get download URL
    const downloadStart = Date.now();
    const downloadUrl = await mediaManager.getDownloadUrl(fileUrl);
    console.log(`Got download URL in ${Date.now() - downloadStart}ms`);

    // Fetch PDF buffer
    const bufferStart = Date.now();
    const buffer = await getFileAsBuffer(downloadUrl);
    console.log(`Downloaded buffer in ${Date.now() - bufferStart}ms`);

    // Parse PDF
    const parseStart = Date.now();
    const data = await pdfParse(buffer);
    const text = data.text || '';
    if (!text.trim().length) throw new Error('No text extracted by pdfParse');
    console.log(`Parsed PDF in ${Date.now() - parseStart}ms, extracted text:`, text.slice(0, 200));

    // Extract menu items
    const extractStart = Date.now();
    const menuItems = await extractInventoryFromText(text, fileUrl, ownerId);
    console.log(`Extracted menu items in ${Date.now() - extractStart}ms`);
    
    let inventoryUpdated = false;
    if (menuItems.length > 0) {
      const upsertStart = Date.now();
      await Promise.all(menuItems.map(item => 
        upsertInventory(item, ownerId, fileUrl).catch(err => {
          console.error(`Error updating item ${item.name || item.itemName_ar}:`, err.message);
        })
      ));
      inventoryUpdated = true;
      console.log(`Upserted menu items in ${Date.now() - upsertStart}ms`);
    } else {
      console.warn('No valid menu items extracted for ownerId:', ownerId);
    }

    // Split text into chunks
    const chunkSize = 300;
    const chunks = [];
    for (let i = 0; i < text.length; i += chunkSize) {
      chunks.push(text.substring(i, Math.min(i + chunkSize, text.length)));
    }

    // Generate embeddings
    const embedStart = Date.now();
    const apiKey = await getSecret('OPENAI_API_KEY');
    const openai = new OpenAI({ apiKey });
    const embeddingPromises = chunks.map(async (chunk) => {
      const embeddingResponse = await openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: chunk
      });
      return embeddingResponse.data[0].embedding;
    });
    const embeddings = await Promise.all(embeddingPromises);
    console.log(`Generated embeddings in ${Date.now() - embedStart}ms`);

    // Store chunks with embeddings
    const storeStart = Date.now();
    const chunkRecords = chunks.map((text, index) => ({
      text,
      embedding: JSON.stringify(embeddings[index]),
      pdfId
    }));
    await wixData.bulkInsert('KnowledgeChunks', chunkRecords);
    console.log(`Stored chunks in ${Date.now() - storeStart}ms`);

    console.log(`Completed PDF processing in ${Date.now() - start}ms`);
    return {
      success: true,
      inventoryUpdated,
      menuItems
    };
  } catch (err) {
    console.error('PDF processing error for ownerId:', ownerId, err.message);
    throw new Error(`Failed to process PDF for ownerId ${ownerId}: ${err.message}`);
  }
}
