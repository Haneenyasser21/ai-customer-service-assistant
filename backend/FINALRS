import wixData from 'wix-data';
import { OpenAI } from 'openai';
import { getSecret } from 'wix-secrets-backend';
import { cosineSimilarity } from './utils';

export async function getTopChunks(ownerId, query) {
  try {
    const pdfs = await wixData.query('PDFs').eq('ownerId', ownerId).find({ suppressAuth: true });
    const pdfIds = pdfs.items.map(item => item._id);

    if (!pdfIds.length) {
      console.warn(`No PDFs found for ownerId ${ownerId}`);
      return [];
    }

    const chunks = await wixData.query('KnowledgeChunks')
      .hasSome('pdfId', pdfIds)
      .limit(1000)
      .find();

    const openai = new OpenAI({ apiKey: await getSecret('OPENAI_API_KEY') });
    const embeddingResponse = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query.toLowerCase().trim()
    });
    const queryEmbedding = embeddingResponse.data[0].embedding;

    let scoredChunks = chunks.items.map(chunk => {
      const chunkEmbedding = JSON.parse(chunk.embedding);
      return {
        text: chunk.text,
        similarity: cosineSimilarity(queryEmbedding, chunkEmbedding),
        pdfId: chunk.pdfId
      };
    });

    scoredChunks.sort((a, b) => b.similarity - a.similarity);
    console.log(`All scored chunks for query "${query}":`, scoredChunks.map(c => ({
      text: c.text.slice(0, 50) + '...',
      similarity: c.similarity.toFixed(3),
      pdfId: c.pdfId
    })));

    let filtered = scoredChunks.filter(c => c.similarity > 0.4).slice(0, 12); // Lower to 0.4, top-k=12
    if (filtered.length === 0 && scoredChunks.length > 0) {
      filtered = scoredChunks.slice(0, 4);
      console.warn("No chunks passed threshold. Using fallback top chunks.");
    }

    console.log(`Filtered top chunks:`, filtered.map(c => ({
      text: c.text.slice(0, 50) + '...',
      similarity: c.similarity.toFixed(3),
      pdfId: c.pdfId
    })));
    return filtered.map(c => c.text);
  } catch (error) {
    console.error('Error in getTopChunks:', error.message);
    return [];
  }
}

// Check if a given item name exists in menu or chunk data
async function checkItemExists(ownerId, itemName, chunks = null) {
  const queryLower = itemName.toLowerCase();

  const menuItems = await wixData.query('MenuItems')
    .eq('ownerId', ownerId)
    .find();

  const inMenu = menuItems.items.some(item =>
    item.name?.toLowerCase().includes(queryLower) ||
    item.itemName_ar?.toLowerCase().includes(queryLower)
  );

  if (!chunks) chunks = await getTopChunks(ownerId, itemName);
  const inChunks = chunks.some(chunk => chunk.toLowerCase().includes(queryLower));

  return inMenu || inChunks;
}

// Main query handler
export async function processQuery(ownerId, query) {
  const isArabic = /[\u0600-\u06FF]/.test(query);
  const queryLower = query.toLowerCase().trim();
  let fullAnswer = '';
  let orderId = null;

  try {
    const chunks = await getTopChunks(ownerId, query);

    // Step 1: Detect user intent using OpenAI
    const openai = new OpenAI({ apiKey: await getSecret('OPENAI_API_KEY') });
    const intentResponse = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: `
You are an intent classifier.

You MUST classify the user's intent into one of these options:
- "order" → if the user is placing an actual food or drink order.
- "availability" → if the user is asking whether something is available.
- "question" → if the user is asking about the system, the menu, how things work, payment, how to order, etc.
- "unknown" → if you're not sure.

Examples:
- "I want a burger" → order
- "Do you have fries?" → availability
- "Can I make an order?" → question
- "How can I pay?" → question
- "Fries" → order
- "Pizza" → order
- "Can I order something?" → question
- "Make custom order?" → question
- "order lamb kebabs" → order
- "get me a coffee" → order

ONLY return one of: order, availability, question, or unknown.
`
        },
        {
          role: 'user',
          content: query
        }
      ]
    });

    const intent = intentResponse.choices[0].message.content.trim().toLowerCase();

    // Step 2: Availability check
    if (intent === 'availability') {
      const itemNameMatch = queryLower.match(/do you have\s+(.+?)(\?|$)/i) ||
                            queryLower.match(/(?:هل لديك|عندك|هل يوجد)\s+(.+?)(\؟|$)/);
      const itemName = itemNameMatch?.[1]?.trim();

      if (itemName) {
        const exists = await checkItemExists(ownerId, itemName, chunks);
        fullAnswer = exists
          ? (isArabic
              ? `Answer: نعم، ${itemName} متوفر لدينا\nEmotion: happy`
              : `Answer: Yes, we have ${itemName}\nEmotion: happy`)
          : (isArabic
              ? `Answer: عذرًا، لا يوجد ${itemName} حاليًا\nEmotion: sad`
              : `Answer: Sorry, we don’t have ${itemName} at the moment\nEmotion: sad`);
        return { message: fullAnswer, orderId: null };
      }
    }

    // Step 3: Order handling
    if (intent === 'order') {
      const quantityMatch = queryLower.match(/(\d+|[٠-٩]+)/);
      const quantity = quantityMatch
        ? parseInt(quantityMatch[1].replace(/[٠-٩]/g, d => '٠١٢٣٤٥٦٧٨٩'.indexOf(d)))
        : 1;

      let itemName = "Unknown";

      // Try extracting item name using patterns
      const orderPattern = /(?:order|bring|i want|هات|عايز|أطلب|اطلب|اوردر|get)\s+(.*?)($|\?|\.|please)/i;
      const match = query.match(orderPattern);
      if (match && match[1]) {
        itemName = match[1].trim();
      }

      // Try scanning menu if item still unknown
      if (!itemName || itemName === "Unknown") {
        const menuItems = await wixData.query('MenuItems').eq('ownerId', ownerId).find();
        const possibleMatch = menuItems.items.find(item =>
          queryLower.includes(item.name?.toLowerCase()) ||
          queryLower.includes(item.itemName_ar?.toLowerCase())
        );
        itemName = possibleMatch?.name || possibleMatch?.itemName_ar || "Unknown";
      }

      // Check if item is valid
      const exists = await checkItemExists(ownerId, itemName, chunks);
      if (!exists) {
        fullAnswer = isArabic
          ? `Answer: عذرًا، لا يوجد ${itemName} حاليًا للطلب\nEmotion: sad`
          : `Answer: Sorry, we don’t have ${itemName} available to order\nEmotion: sad`;
        return { message: fullAnswer, orderId: null };
      }

      // Generate order ID and respond
      orderId = `ORDER_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
      fullAnswer = isArabic
        ? `Answer: جاري معالجة طلبك من ${quantity} ${itemName === "lamb kebabs" ? "كباب خروف" : itemName}\nEmotion: happy`
        : `Answer: Processing your order of ${quantity} ${itemName}${quantity > 1 ? 's' : ''}\nEmotion: happy`;
      console.log("Debug: isArabic =", isArabic, "query =", query, "fullOrderAnswer =", fullAnswer, "itemName =", itemName);
      return { message: fullAnswer, orderId };
    }

    // Step 4: General RAG-based answer
    const instructions = `
      You are a customer service assistant responding in the user's language.
      You must only use the provided PDF chunk context to answer the user's question. Use the exact text from the chunks where possible, and do not add any information or assumptions beyond what is explicitly contained in the chunks. If no relevant context is found across all provided chunks, say 'I don’t have enough information from the PDF to answer.'
      Choose one of the following emotions: happy, sad, angry, surprised, outofservice.
      Format:
      Answer: [your reply]
      Emotion: [emotion]
    `;
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: instructions },
        { role: 'user', content: `${query}\n\nContext:\n${chunks.join('\n')}` }
      ]
    });

    const aiMessage = response.choices[0].message.content;
    const answerMatch = aiMessage.match(/Answer:\s*(.*?)\s*Emotion:/is);
    const emotionMatch = aiMessage.match(/Emotion:\s*(.*)/i);
    const answer = answerMatch?.[1]?.trim() || (isArabic ? "لم يتم توفير إجابة." : "No answer provided.");
    const emotion = emotionMatch?.[1]?.trim().toLowerCase() || "neutral";

    return {
      message: `Answer: ${answer}\nEmotion: ${emotion}`,
      orderId: null
    };

  } catch (error) {
    console.error('Error in processQuery:', error);
    return {
      message: isArabic
        ? `Answer: حدث خطأ أثناء المعالجة.\nEmotion: outofservice`
        : `Answer: An error occurred during processing.\nEmotion: outofservice`,
      orderId: null
    };
  }
}
