import wixData from 'wix-data';
import { mediaManager } from 'wix-media-backend';
import pdfParse from 'pdf-parse';
import { OpenAI } from 'openai';
import { getSecret } from 'wix-secrets-backend';
import https from 'https';

// Download file as buffer
async function getFileAsBuffer(url) {
    return new Promise((resolve, reject) => {
        const req = https.get(url, (res) => {
            if (res.statusCode !== 200) {
                reject(new Error(`Failed with status code: ${res.statusCode}`));
                return;
            }
            const chunks = [];
            res.on('data', (chunk) => chunks.push(chunk));
            res.on('end', () => {
                const buffer = Buffer.concat(chunks);
                resolve(buffer);
            });
        });
        req.on('error', reject);
    });
}

// Translate English to Arabic
// Translate English to Arabic
async function translateToArabic(text, openai) {
    try {
        console.log(`Translating "${text}" to Arabic...`);
        const response = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
                { role: 'system', content: 'Translate the English menu item name to Arabic.' },
                { role: 'user', content: text }
            ],
            temperature: 0.3
        });
        const translation = response.choices[0].message.content.trim();
        console.log(`Translated "${text}" to "${translation}"`);
        return translation;
    } catch (err) {
        console.error(`Translation failed for "${text}":`, { message: err.message, stack: err.stack, error: err });
        return text; // Fallback to English
    }
}

// // Upsert inventory item
async function upsertInventory(item, ownerId, fileUrl) {
    const {
        name = '', itemName_ar = '',
        description_en = '', description_ar = '',
        quantity = 0, price = 0
    } = item;

    if (!name && !itemName_ar) {
        console.warn(`Skipping invalid item (no name) for ownerId: ${ownerId}`, item);
        return;
    }

    const normalizedName = name.toLowerCase().split(' ').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');

    const data = {
        ownerId,
        name: normalizedName || itemName_ar,
        itemName_ar,
        description_en,
        description_ar,
        quantity,
        price,
        sourcePdfUrl: fileUrl // Add this line to store the fileUrl
    };

    const existing = await wixData.query('MenuItems')
        .eq('ownerId', ownerId)
        .eq('name', normalizedName)
        .find();
    if (existing.items.length > 0) {
        await wixData.update('MenuItems', { ...existing.items[0], ...data });
        console.log(`Updated item for ownerId ${ownerId}: ${normalizedName}`);
    } else {
        await wixData.insert('MenuItems', data);
        console.log(`Inserted item for ownerId ${ownerId}: ${normalizedName}`);
    }
}

// Extract items using OpenAI with bilingual support
async function extractInventoryFromText(text, fileUrl, ownerId) {
    const apiKey = await getSecret('OPENAI_API_KEY');
    const openai = new OpenAI({ apiKey });

    const systemPrompt = `
Extract a bilingual JSON array from a restaurant menu in Arabic and English.

Each object must contain:
- "itemName_ar" (Arabic name if present, leave empty if not)
- "name" (English name if present)
- "quantity" (numeric, default 1 if missing, extract from text like ': 12' or '12')
- "price" (numeric, extract price in EGP like '12 EGP' or '11 EGP', default 0 if not found)
- "description_ar" and "description_en" (if available, empty string if not)

Return *only a valid JSON array*. No text or explanations.
    `;

    const userContent = `
Text: ${text.slice(0, 4000)}
Source: ${fileUrl}
    `;

    const response = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userContent }
        ],
        temperature: 0.3,
        max_tokens: 4096
    });

    let raw = response.choices[0].message.content?.trim();
    console.log(`Raw OpenAI response for ownerId: ${ownerId} -`, raw);

    // Strip ```json ... ``` if present
    if (raw.startsWith("```json")) raw = raw.slice(7);
    if (raw.endsWith("```")) raw = raw.slice(0, -3);

    let parsed;
    try {
        parsed = JSON.parse(raw);
    } catch (err) {
        try {
            const fixed = raw.replace(/,\s*$/, '') + ']'; // Attempt to fix if cut off
            parsed = JSON.parse(fixed);
        } catch (secondErr) {
            console.error(`Invalid JSON from OpenAI for ownerId: ${ownerId}, Raw: ${raw}, Error:`, { message: secondErr.message, stack: secondErr.stack });
            throw new Error('Invalid JSON from OpenAI');
        }
    }

    if (!Array.isArray(parsed)) {
        console.warn(`Expected JSON array, got: ${typeof parsed} for ownerId: ${ownerId}`);
        return [];
    }

    // Translate all English names to Arabic
    for (let item of parsed) {
        if (item.name) {
            console.log(`Attempting translation for item: ${item.name}`);
            item.itemName_ar = await translateToArabic(item.name, openai);
        }
        // Ensure description fields are strings
        item.description_ar = item.description_ar ?? '';
        item.description_en = item.description_en ?? '';
    }

    const validItems = parsed.filter(i => (i.name || i.itemName_ar) && (i.name.trim().length > 0 || i.itemName_ar.trim().length > 0));
    console.log(`Validated menu items for ownerId: ${ownerId} -`, validItems);
    return validItems;
}
// Main entry point
export async function uploadAndProcessPDF(fileUrl, ownerId) {
    try {
        console.log('Processing file for ownerId:', ownerId, fileUrl);

        // Step 1: Create a new PDF record
        const newPDF = await wixData.insert('PDFs', { fileUrl, ownerId });
        const pdfId = newPDF._id;

        // Step 2: Get download URL
        const downloadUrl = await mediaManager.getDownloadUrl(fileUrl);

        // Step 3: Fetch PDF as buffer
        const buffer = await getFileAsBuffer(downloadUrl);

        // Step 4: Parse PDF to extract text
        const data = await pdfParse(buffer);
        const text = data.text || '';
        if (!text.trim().length) throw new Error('No text extracted by pdfParse');
        console.log('Extracted text for ownerId:', ownerId, text.slice(0, 200));

        // Step 5: Extract menu items
        const menuItems = await extractInventoryFromText(text, fileUrl, ownerId);
        console.log('Extracted menu items count for ownerId:', ownerId, menuItems.length);

        let inventoryUpdated = false;
        if (menuItems.length > 0) {
            for (const item of menuItems) {
                try {
                    await upsertInventory(item, ownerId, fileUrl); // Add fileUrl as the third argument
                    inventoryUpdated = true;
                } catch (err) {
                    console.error(`Error updating item for ownerId ${ownerId}: ${item.name || item.itemName_ar}`, err.message);
                }
            }
        } else {
            console.warn('No valid menu items extracted for ownerId:', ownerId);
        }

        // Step 6: Split text into chunks for embeddings
        const chunkSize = 300;
        const chunks = [];
        for (let i = 0; i < text.length; i += chunkSize) {
            chunks.push(text.substring(i, Math.min(i + chunkSize, text.length)));
        }

        // Step 7: Generate embeddings
        const apiKey = await getSecret('OPENAI_API_KEY');
        const openai = new OpenAI({ apiKey });
        const embeddingPromises = chunks.map(async (chunk) => {
            try {
                const embeddingResponse = await openai.embeddings.create({
                    model: 'text-embedding-3-small',
                    input: chunk
                });
                return embeddingResponse.data[0].embedding;
            } catch (err) {
                console.warn(`Embedding failed for chunk in ownerId ${ownerId}:`, err.message);
                return null;
            }
        });
        const embeddings = await Promise.all(embeddingPromises);

        // Step 8: Store chunks with embeddings
        const chunkRecords = chunks
            .map((text, index) => ({
                text,
                embedding: embeddings[index] ? JSON.stringify(embeddings[index]) : null,
                pdfId
            }))
            .filter(record => record.embedding);
        if (chunkRecords.length > 0) {
            await wixData.bulkInsert('KnowledgeChunks', chunkRecords);
            console.log('Inserted knowledge chunks for ownerId:', ownerId, chunkRecords.length);
            
        }

        return {
            success: true,
            inventoryUpdated,
            menuItems
        };
    } catch (err) {
        console.error('PDF processing error for ownerId:', ownerId, err.message);
        throw new Error(`Failed to process PDF for ownerId ${ownerId}: ${err.message}`);
    }
}
