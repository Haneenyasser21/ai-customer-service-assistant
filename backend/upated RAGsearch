import wixData from 'wix-data';
import { OpenAI } from 'openai';
import { getSecret } from 'wix-secrets-backend';
import { cosineSimilarity } from './utils';

// Cache for query chunks (per session)
const chunkCache = new Map();

async function getTopChunks(ownerId, query) {
  if (!ownerId || !query) {
    console.error("Invalid input: ownerId or query is undefined", { ownerId, query });
    return [];
  }

  const cacheKey = `${ownerId}:${query}`;
  if (chunkCache.has(cacheKey)) {
    console.log("Using cached chunks for query:", query);
    return chunkCache.get(cacheKey);
  }

  const pdfs = await wixData.query('PDFs')
    .eq('ownerId', ownerId)
    .find({ suppressAuth: true });

  if (pdfs.items.length === 0) {
    console.warn("No PDFs found for ownerId:", ownerId);
    return [];
  }

  const pdfIds = pdfs.items.map(item => item._id);
  const chunks = await wixData.query('KnowledgeChunks')
    .hasSome('pdfId', pdfIds)
    .find();

  if (chunks.items.length === 0) {
    console.warn("No KnowledgeChunks found for pdfIds:", pdfIds);
    return [];
  }

  const openai = new OpenAI({ apiKey: await getSecret('OPENAI_API_KEY') });
  const embeddingResponse = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: query
  });

  const queryEmbedding = embeddingResponse.data[0].embedding;
  let topChunks = chunks.items.map(chunk => {
    const chunkEmbedding = JSON.parse(chunk.embedding);
    return {
      text: chunk.text,
      similarity: cosineSimilarity(queryEmbedding, chunkEmbedding)
    };
  });

  topChunks.sort((a, b) => b.similarity - a.similarity);
  const relevantChunks = topChunks.filter(c => c.text.toLowerCase().includes(query.toLowerCase().replace(/what are the|what is your/, '').trim()));
  const selectedChunks = relevantChunks.length > 0 ? relevantChunks.slice(0, 5).map(c => c.text) : topChunks.slice(0, 5).map(c => c.text);
  chunkCache.set(cacheKey, selectedChunks);
  console.log("Top Chunks for query:", query, selectedChunks.map(c => c.text));
  return selectedChunks;
}

// Retrieve all chunks for display
export async function getAllChunks(ownerId) {
  const pdfs = await wixData.query('PDFs')
    .eq('ownerId', ownerId)
    .find({ suppressAuth: true });

  if (pdfs.items.length === 0) {
    console.warn("No PDFs found for ownerId:", ownerId);
    return [];
  }

  const pdfIds = pdfs.items.map(item => item._id);
  const chunks = await wixData.query('KnowledgeChunks')
    .hasSome('pdfId', pdfIds)
    .find();

  return chunks.items.map(chunk => chunk.text);
}

// Check if a given item name exists in menu or chunk data
async function checkItemExists(ownerId, itemName, chunks = null) {
  const queryLower = itemName.toLowerCase().trim();
  const menuItems = await wixData.query('MenuItems')
    .eq('ownerId', ownerId)
    .find();

  const inMenu = menuItems.items.some(item =>
    item.name?.toLowerCase().includes(queryLower) ||
    item.itemName_ar?.toLowerCase().includes(queryLower)
  );

  if (!chunks) chunks = await getTopChunks(ownerId, itemName);
  const inChunks = chunks.some(chunk => chunk.toLowerCase().includes(queryLower));

  return inMenu || inChunks;
}

// Main query handler
export async function processQuery(ownerId, query) {
  if (!ownerId || !query) {
    console.error("Invalid input to processQuery:", { ownerId, query });
    return {
      message: "Answer: Invalid request.\nEmotion: outofservice",
      orderId: null,
      chunks: []
    };
  }

  const isArabic = /[\u0600-\u06FF]/.test(query);
  const queryLower = query.toLowerCase().trim();
  let fullAnswer = '';
  let orderId = null;

  try {
    const chunks = await getTopChunks(ownerId, query);
    console.log("Processed Chunks:", chunks);

    if (chunks.length === 0) {
      console.warn("No chunks available for query:", query);
      return {
        message: isArabic
          ? "Answer: لا يوجد معلومات متاحة.\nEmotion: outofservice"
          : "Answer: No information available.\nEmotion: outofservice",
        orderId: null,
        chunks: []
      };
    }

    const openai = new OpenAI({ apiKey: await getSecret('OPENAI_API_KEY') });
    let intentResponse;
    try {
      intentResponse = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `
You are an intent classifier.

You MUST classify the user's intent into one of these options:
- "order" → if the user is placing an actual food or drink order.
- "availability" → if the user is asking whether something is available.
- "question" → if the user is asking about the system, the menu, how things work, payment, how to order, etc.
- "unknown" → if you're not sure.

Examples:
- "I want a burger" → order
- "Do you have fries?" → availability
- "Can I make an order?" → question
- "How can I pay?" → question
- "Fries" → order
- "Pizza" → order
- "Can I order something?" → question
- "Make custom order?" → question

ONLY return one of: order, availability, question, or unknown.
`
          },
          {
            role: 'user',
            content: query
          }
        ]
      });
    } catch (intentError) {
      console.error("Intent classification failed:", intentError.message);
    }

    const intent = intentResponse?.choices[0]?.message?.content?.trim().toLowerCase() || "unknown";

    let intentHandled = false;

    if (intent === 'availability') {
      const itemNameMatch = queryLower.match(/do you have\s+(.+?)(\?|$)/i) ||
                            queryLower.match(/(?:هل لديك|عندك|هل يوجد)\s+(.+?)(\؟|$)/);
      const itemName = itemNameMatch?.[1]?.trim();

      if (itemName) {
        const exists = await checkItemExists(ownerId, itemName, chunks);
        fullAnswer = exists
          ? (isArabic
              ? `Answer: نعم، ${itemName} متوفر لدينا\nEmotion: happy`
              : `Answer: Yes, we have ${itemName}\nEmotion: happy`)
          : (isArabic
              ? `Answer: عذرًا، لا يوجد ${itemName} حاليًا\nEmotion: sad`
              : `Answer: Sorry, we don’t have ${itemName} at the moment\nEmotion: sad`);
        intentHandled = true;
      }
    } else if (intent === 'order') {
      const quantityMatch = queryLower.match(/(\d+|[٠-٩]+)/);
      const quantity = quantityMatch
        ? parseInt(quantityMatch[1].replace(/[٠-٩]/g, d => '٠١٢٣٤٥٦٧٨٩'.indexOf(d)))
        : 1;

      let itemName = "Unknown";

      const orderPattern = /(?:order|bring|i want|هات|عايز|أطلب|اطلب|اوردر)\s+(.*?)($|\?|\.|please)/i;
      const match = query.match(orderPattern);
      if (match && match[1]) {
        itemName = match[1].trim();
      }

      if (!itemName || itemName === "Unknown") {
        const menuItems = await wixData.query('MenuItems').eq('ownerId', ownerId).find();
        const possibleMatch = menuItems.items.find(item =>
          queryLower.includes(item.name?.toLowerCase()) ||
          queryLower.includes(item.itemName_ar?.toLowerCase())
        );
        itemName = possibleMatch?.name || possibleMatch?.itemName_ar || "Unknown";
      }

      const exists = await checkItemExists(ownerId, itemName, chunks);
      if (exists) {
        orderId = `ORDER_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        fullAnswer = isArabic
          ? `Answer: جاري معالجة طلبك من ${quantity} ${itemName}\nEmotion: happy`
          : `Answer: Processing your order of ${quantity} ${itemName}${quantity > 1 ? 's' : ''}\nEmotion: happy`;
        intentHandled = true;
      } else {
        fullAnswer = isArabic
          ? `Answer: عذرًا، لا يوجد ${itemName} حاليًا للطلب\nEmotion: sad`
          : `Answer: Sorry, we don’t have ${itemName} available to order\nEmotion: sad`;
        intentHandled = true;
      }
    }

    if (!intentHandled || chunks.length > 0) {
      const instructions = `
        You are a customer service assistant responding in the user's language.
        You MUST base your answer *ONLY* on the provided context. Do not add information outside the context, make assumptions, or use your training data. If the context does not contain relevant information, say: "I don't have information on that."
        Your answer must directly quote or closely paraphrase the exact text from the context that matches the query. Do not invent details or generalize.
        Format your response exactly as: Answer: [your reply] Emotion: [emotion]
        Choose one of the following emotions: happy, sad, angry, surprised, outofservice.
      `;

      const response = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: instructions },
          { role: 'user', content: `${query}\n\nContext:\n${chunks.join('\n')}` }
        ]
      });

      console.log("Raw OpenAI Response:", response.choices[0].message.content);
      const aiMessage = response.choices[0].message.content;
      const answerMatch = aiMessage.match(/Answer:\s*(.*?)\s*Emotion:/is);
      const emotionMatch = aiMessage.match(/Emotion:\s*(.*)/i);
      const answer = answerMatch?.[1]?.trim() || (isArabic ? "لم يتم توفير إجابة." : "No answer provided.");
      const emotion = emotionMatch?.[1]?.trim().toLowerCase() || "outofservice";

      return {
        message: `Answer: ${answer}\nEmotion: ${emotion}`,
        orderId: null,
        chunks: chunks
      };
    }

    return {
      message: isArabic
        ? "Answer: لا يوجد معلومات متاحة.\nEmotion: outofservice"
        : "Answer: No information available.\nEmotion: outofservice",
      orderId: null,
      chunks: []
    };

  } catch (error) {
    console.error('Error in processQuery:', error.message, error.stack);
    return {
      message: isArabic
        ? `Answer: حدث خطأ أثناء المعالجة.\nEmotion: outofservice`
        : `Answer: An error occurred during processing.\nEmotion: outofservice`,
      orderId: null,
      chunks: []
    };
  }
}
